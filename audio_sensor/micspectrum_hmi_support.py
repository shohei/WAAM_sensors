#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Oct 12, 2024 10:06:52 PM JST  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

import micspectrum_hmi

import pyaudio
import threading
import matplotlib.pyplot as plot
import numpy
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import librosa
import librosa.display

devices = []
audio = None
stream = None
fig = None
ax = None
canvas = None

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = micspectrum_hmi.Toplevel1(_top1)

    list_microphones(_w1.TCombobox1)
    _w1.TCombobox1.bind("<<ComboboxSelected>>", device_on_selected)

    global fig, ax, canvas
    fig, ax = plot.subplots()
    canvas = FigureCanvasTkAgg(fig, master=_w1.Canvas1)
    canvas.get_tk_widget().pack(fill=BOTH, expand=True)  # pack を追加
    
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.axhline(y=0, color='black', linewidth=0.5)
    
    canvas.draw()

    root.mainloop()


def list_microphones( combo ):
    global devices
    
    p = pyaudio.PyAudio()
    info = p.get_host_api_info_by_index(0)
    numdevices = info.get('deviceCount')
    updated_values=[]
    for i in range(0, numdevices):
        if (p.get_device_info_by_host_api_device_index(0, i).get('maxInputChannels')) > 0:
             # デバイスをリストに追加
            devices.append({
                "index": i,
                "name": p.get_device_info_by_host_api_device_index(0, i).get('name'),
                "maxInputChannels": p.get_device_info_by_host_api_device_index(0, i).get('maxInputChannels'),
                "maxOutputChannels": p.get_device_info_by_host_api_device_index(0, i).get('maxOutputChannels'),
                "defaultSampleRate": p.get_device_info_by_host_api_device_index(0, i).get('defaultSampleRate')
            })
            new_value = f"Input Device  {i}"
            updated_values.append(new_value)
            
            
    p.terminate()
    combo["values"] =updated_values
    
    
def device_on_selected(event):
    global _w1
    # イベント発生元のウィジェットを取得
    widget = event.widget
    selected_value = widget.get()  # イベント発生元のComboboxの選択された値を取得
    #print(f"Selected value from {widget}: {selected_value}")
    
    device_number = int(selected_value.split("Device ")[1])
    
    device = devices[device_number]
    device_info = (
            f"Index: {device['index']}, \n"
            f"name: {device['name']}, \n"
            f"maxInputChannels: {device['maxInputChannels']}, \n"
            f"maxOutputChannels: {device['maxOutputChannels']}, \n"
            f"defaultSampleRate: {device['defaultSampleRate']}, \n"
        )
    _w1.Scrolledtext1.delete(1.0, 'end')  # 全削除（0から末尾まで）
    _w1.Scrolledtext1.insert('end', device_info)  # 新しいテキストを挿入
    
def connect_button_on_click(*args):
    global _w1
    if _w1.TButton1['text']=="Connect":
        _w1.TButton1['text']="Disconnect"
        selected_index = _w1.TCombobox1.current()  # 選択されたインデックスを取得
        if 0 <= selected_index < len(devices):  # インデックスが有効範囲内か確認
            device_index = devices[selected_index]["index"]
            audiostart(device_index) # 選択されたデバイスのインデックスを渡す
            plotting_thread = threading.Thread(target=read_plot_data) # スレッドに名前を付ける
            plotting_thread.daemon = True # デーモンスレッド化
            plotting_thread.start()
    else:
        _w1.TButton1['text']="Connect"
        audiostop()
    

def audiostart( device_index ):
    global audio, stream
    try:
        audio = pyaudio.PyAudio()
        stream = audio.open(format=pyaudio.paInt16,
                            rate=44100,
                            channels=1,
                            input_device_index=device_index, # ここで使用する
                            input=True,
                            frames_per_buffer=10240)
    except OSError as e:
        print(f"Error opening stream: {e}")
        stream = None # エラー発生時はstreamをNoneにする
        # 必要に応じてエラーメッセージをGUIに表示する処理を追加
                
def audiostop():
    global audio, stream, plotting_thread # plotting_thread を追加
    if stream:
        stream.stop_stream()
        stream.close()
    if audio:
        audio.terminate()
    stream = None # stream を None に設定

def read_plot_data():
    global stream, canvas, fig, ax
    if stream is None or canvas is None or fig is None or ax is None:
        return

    while stream: # stream が存在する間ループ
        try:
            data = stream.read(10240)
            audiodata = numpy.frombuffer(data, dtype='int16')
            # スペクトログラムを計算 & dBスケールに変換
            stft_result = librosa.stft(audiodata.astype(numpy.float32), n_fft=2048, hop_length=512)
            spectrogram = numpy.abs(stft_result)**2
            log_spectrogram = librosa.power_to_db(spectrogram)
                    
            ax.cla()  # 毎回クリア

            # スペクトログラムを表示
            librosa.display.specshow(log_spectrogram, sr=44100, hop_length=512, x_axis='time', y_axis='log', ax=ax)            
            canvas.draw()
        except OSError as e:
            print(f"Error reading from stream: {e}")
            audiostop() # エラー発生時はstreamを停止
            break # ループを抜ける
    
if __name__ == '__main__':
    mic_hmi.start_up()
